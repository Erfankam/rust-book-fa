## پیوست آ: کلیدواژه‌ها

فهرست زیر حاوی کلمات کلیدی است که برای استفاده کنونی یا آینده توسط زبان Rust اختصاص‌داده شده‌اند. به این ترتیب، این واژگان نمی‌توانند به عنوان شناسه استفاده شوند (به جز به عنوان شناسه‌های خام که در بخش «[Raw Identifiers][raw-identifier]<!-- ignore -->» بحث خواهیم کرد)، از جمله نام تابع‌ها، متغیرها، مقدارهای ورودی، مشخصه‌های ساختاری، مؤلفه‌ها، جعبه‌ها، ثابت‌ها، ماکروها، مقدارهای ثابت، ویژگی‌ها، نوع‌ها، صفت‌ها یا طول عمر.

[raw-identifiers]: #raw-identifiers

### کلیدواژه‌های که در حال حاضر استفاده می‌شوند

واژگان کلیدی زیر در حال حاضر دارای عملکرد توصیف‌‌شده‌ی زیر هستند.

* `as` - تغییر نوع اولیه (primitive casting) را انجام می‌دهد، صفت مشخصی از دارنده‌ی آن شامل یک مورد (Item) را ابهام‌زدایی می‌کند،
  یا نام موارد را در دستورات `use` و `extern crate` تغییر می‌دهد.
* `async` - به جای این‌که نخ کنونی را متوقف کند، نوع `Future` را باز می‌گرداند.
* `await` - روند اجرای کد را تا زمانی‌که نتیجه‌ی یک `Future` آماده باشد، متوقف می‌کند.
* `break` - مستقیماً از حلقه خارج می‌شود.
* `const` - موارد ثابت یا اشاره‌گرهای خام ثابت را تعریف می‌کند.
* `continue` - به تکرار حلقه‌ی بعد ادامه می‌دهد.
* `crate` - یک کتابخانه‌ی خارجی یا یک متغیر ماکرو را که نشان دهنده کتابخانه‌ای که ماکرو در آن تعریف شده است، پیوند می‌دهد.
* `dyn` - ارسال پویا به یک شئ اشاره‌گر
* `else` - بازتعریفی برای ساختارهای کنترل جریان کد `if` و `if let` ارائه می‌دهد.
* `enum` - یک نوع داده‌ی شمارش‌پذیر را تعریف می‌کند.
* `extern` - یک کتابخانه‌ی خارجی، تابع یا متغیر را پیوند می‌دهد.
* `false` - مقدار نادرست (false) در منطق بولی را نشان می‌کند.
* `fn` - یک تابع و یا نوع اشاره‌گر تابع را تعریف می‌کند.
* `for` - موارد یک تکرارکننده که یک ویژگی را پیاده‌سازی می‌کند یا طول عمر بالاتری را مشخص می‌کند، پیمایش می‌کند.
* `if` - بر اساس نتیجه یک عبارت شرطی ایجاد شاخه می‌کند.
* `impl` - عملکرد ذاتی یا ویژگی خاص (trait) را پیاده می‌کند.
* `in` - بخشی از حلقه‌ی `for` می‌باشد.
* `let` - یک متغیر را تغریف می‌کند.
* `loop` - حلقه‌ی بدون شرط را اجرا می‌کند.
* `match` - یک مقدار را با الگو تطبیق می‌دهد.
* `mod` - یک ماژول را تعریف می‌کند.
* `move` - یک بسته مالکیت تمام ضبط آن را می‌سازد.
* `mut` - تغییرپذیری در مراجع، اشاره گرهای خام یا پیوندهای الگو را نشان می دهد
* `pub` - قابلیت استفاده‌ی عمومی در فیلدهای ساختار (struct)، بلوک‌های «impl» یا ماژول‌ها را نشان می‌دهد
* `ref` - یک ارجاع را تعریف می‌کند.
* `return` - مقدار تابع را باز می‌گرداند.
* `Self` - یک نام مستعار برای نوع داده‌ای که در حال تعریف یا پیاده‌سازی آن هستیم، تعریف می‌کند.
* `self` - دارنده‌ی تابع و یا ماژول کنونی را نشان می‌دهد.
* `static` - متغیر سراسری یا طول عمری که کل اجرای برنامه را دوام می آورد
* `struct` - یک نوع داده‌ی ساختار (struct) را تعریف می‌کند.
* `super` - به ماژول والد ماژول جاری اشاره می‌کند.
* `trait` - یک نوع داده‌ی اشاره‌گر را تعریف می‌کند.
* `true` - مقدار درست (true) در منطق بولی را نشان می‌کند.
* `type` - یک نوع مستعار یا نوع مرتبط را تعریف ‌می‌کند.
* `unsafe` - کد، توابع، اشاره‌گرها یا پیاده‌سازی‌های ناامن را نشان می دهد.
* `use` - نام‌ (symbol) کتابخانه‌ها را در یک دامنه بازتعریف می‌کند.
* `where` - عبارت هایی را نشان می دهد که یک نوع را محدود می کند
* `while` - یک حلقه را با توجه به نتیجه‌ی عبارت شرطی تکرار می‌کند.

### کلیدواژه‌هایی که برای آینده اختصاص یافته‌اند

کلیدواژه‌های زیر هیچ گونه عملکردی ندارند، اما توسط Rust برای استفاده‌ی احتمالی در آینده محفوظ هستند.

* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`

### شناسه‌های خام

*شناسه‌های خام* روشی هستند که به شما امکان می‌دهند از کلمات کلیدی در جایی استفاده کنید که معمولاً مجاز نیستند. شما با قرار دادن پیشوند کلمه کلیدی با `r#` از یک شناسه‌ی خام استفاده می‌کنید.

به عنوان نمونه، `match` یک کلیدواژه است. اگر تلاش کنید تابع زیر را کامپایل کنید
که از `match` به عنوان نام خود استفاده می کند:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

این خطا را دریافت خواهید کرد:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

خطا نشان می دهد که نمی توانید از کلیدواژه‌ی `match` به عنوان شناسه‌ی تابع استفاده کنید. برای استفاده از `match` به عنوان نام تابع، باید از شناسایی خام استفاده کنید، مانند این:

<span class="filename">Filename: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
  haystack.contains(needle)
}

fn main() {
  assert!(r#match("foo", "foobar"));
}
```

این کد بدون هیچ خطایی کامپایل می شود. به پیشوند "r#" روی نام تابع در تعریف آن و همچنین جایی که تابع در "main" فراخوانی می شود، توجه کنید.

شناسه های خام به شما امکان می دهند از هر واژه‌ای که برمی‌گزینید، به عنوان شناسه استفاده کنید، حتی اگر آن واژه، یک کلیدواژه‌ی اختصاص یافته باشد. علاوه بر این، شناسه‌های خام به شما امکان می‌دهند از کتابخانه‌های نوشته شده در نسخه Rust متفاوتی نسبت به موارد استفاده در کتابخانه‌های خود استفاده کنید. به عنوان مثال، `try` در نسخه ۲۱۰۵ یک کلیدواژه نیست، ولی در نسخه ۲۰۱۸ یک کلیدواژه است.  اگر به کتابخانه‌ای وابسته هستید که با استفاده از نسخه ۲۰۱۵ نوشته شده است و تابع `try` دارد، باید از نحو شناسایی خام، `r#try` در این مورد استفاده کنید تا آن تابع را از کد نسخه ۲۰۱۸ خود فراخوانی کنید. برای آگاهی بیشتر به پیوست  [Appendix E][appendix-e]<!-- ignore --> مراجعه کنید.

[appendix-e]: appendix-05-editions.html
